#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 1 ]]; then
    echo "uso: $(basename "$0") <arquivo1.c> [arquivo2.c ...]" >&2
    exit 1
fi

mkdir -p build

functions_h="build/returb_merged_libs.h"
dictionary_h="build/returb_dictionary.h"
array_h="build/returb_function_names.h"

# limpa os arquivos antigos
: > "$functions_h"
: > "$dictionary_h"
: > "$array_h"

declare -a funcs=()

# percorre os arquivos e coleta os nomes de função
for file in "$@"; do
    cat "$file" >> "$functions_h"
    echo "" >> "$functions_h"

    # usa regex para extrair nomes de funções void nome(List* stack)
    while IFS= read -r func; do
        funcs+=("$func")
    done < <(grep -oP 'void\s+\K[A-Za-z_][A-Za-z0-9_]*(?=\s*\(List\*\s*stack\))' "$file" || true)
done

# gera dictionary.h
for func in "${funcs[@]}"; do
    echo "#define $func __COUNTER__" >> "$dictionary_h"
done

# gera array.h
{
    echo "#ifndef RETURB_FUNCTIONS_NAMES_AVAILABLE"
    echo "#define RETURB_FUNCTIONS_NAMES_AVAILABLE 1"

    echo "static const char *returb_function_names[] = {"
    for func in "${funcs[@]}"; do
        echo "    \"$func\","
    done
    echo "    0"
    echo "};"
    echo "#endif"
} >> "$array_h"

# gera macro INIT_RETURB em functions.h
{
    echo ""
    echo "#define INIT_RETURB(context) \\"
    for func in "${funcs[@]}"; do
        echo "    returb_push(context, (Value){.p = $func}); \\"
    done
    echo "    ((void)0)"
} >> "$functions_h"

cp compiler.c ./build/
cp interpreter.c ./build/
